<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust API Guidelines</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="This is a set of recommendations on how to design and present APIs for the Rust programming language.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">关于</a></li><li class="chapter-item expanded affix "><a href="checklist.html">检查表</a></li><li class="chapter-item expanded "><a href="naming.html"><strong aria-hidden="true">1.</strong> 命名</a></li><li class="chapter-item expanded "><a href="interoperability.html"><strong aria-hidden="true">2.</strong> 互操作性</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> 宏</a></li><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">4.</strong> 文档</a></li><li class="chapter-item expanded "><a href="predictability.html"><strong aria-hidden="true">5.</strong> 可预测性</a></li><li class="chapter-item expanded "><a href="flexibility.html"><strong aria-hidden="true">6.</strong> 灵活性</a></li><li class="chapter-item expanded "><a href="type-safety.html"><strong aria-hidden="true">7.</strong> 类型安全</a></li><li class="chapter-item expanded "><a href="dependability.html"><strong aria-hidden="true">8.</strong> 可靠性</a></li><li class="chapter-item expanded "><a href="debuggability.html"><strong aria-hidden="true">9.</strong> 可调试性</a></li><li class="chapter-item expanded "><a href="future-proofing.html"><strong aria-hidden="true">10.</strong> 前瞻性</a></li><li class="chapter-item expanded "><a href="necessities.html"><strong aria-hidden="true">11.</strong> 必要性</a></li><li class="chapter-item expanded affix "><a href="external-links.html">外部链接</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust API Guidelines</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-api-指南"><a class="header" href="#rust-api-指南">Rust API 指南</a></h1>
<p>这是关于如何设计和展示 Rust 编程语言的 API 的一系列推荐。这些指南主要由 Rust 库团队撰写，基于构建 Rust 标准库和 Rust 生态系统中其他 crate 的经验。</p>
<p>这些只是指南，其中一些更为严格，而其他的则比较模糊且仍在开发中。Rust crate 作者应将它们视为开发惯用和可互操作的 Rust 库时需要考虑的一系列重要因素，可以根据需要使用它们。这些指南不应被视为 crate 作者必须遵循的强制性规定，尽管他们可能会发现，与这些指南高度兼容的 crate 比那些不兼容的 crate 更好地集成到现有的 crate 生态系统中。</p>
<p>本书分为两部分：适合在 crate 评审期间快速浏览的所有单独指南的简明 [清单]；以及包含详细指南解释的专题章节。</p>
<p>如果你有兴趣为 API 指南做出贡献，请查阅 <a href="https://github.com/rust-lang/api-guidelines/blob/master/CONTRIBUTING.md">contributing.md</a> 并加入我们的 [Gitter 频道]。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-api-指南检查清单"><a class="header" href="#rust-api-指南检查清单">Rust API 指南检查清单</a></h1>
<!-- 在编写新指南之前，请阅读 CONTRIBUTING.md -->
<ul>
<li><strong>命名</strong> <em>(crate 符合 Rust 命名约定)</em>
<ul>
<li><input disabled="" type="checkbox"/>
命名符合 RFC 430 (<a href="naming.html#c-case">C-CASE</a>)</li>
<li><input disabled="" type="checkbox"/>
临时转换遵循 <code>as_</code>, <code>to_</code>, <code>into_</code> 约定 (<a href="naming.html#c-conv">C-CONV</a>)</li>
<li><input disabled="" type="checkbox"/>
Getter 名称遵循 Rust 约定 (<a href="naming.html#c-getter">C-GETTER</a>)</li>
<li><input disabled="" type="checkbox"/>
集合上的方法生成迭代器遵循 <code>iter</code>, <code>iter_mut</code>, <code>into_iter</code> (<a href="naming.html#c-iter">C-ITER</a>)</li>
<li><input disabled="" type="checkbox"/>
迭代器类型名称与生成它们的方法匹配 (<a href="naming.html#c-iter-ty">C-ITER-TY</a>)</li>
<li><input disabled="" type="checkbox"/>
功能名称没有占位符词语 (<a href="naming.html#c-feature">C-FEATURE</a>)</li>
<li><input disabled="" type="checkbox"/>
名称使用一致的词序 (<a href="naming.html#c-word-order">C-WORD-ORDER</a>)</li>
</ul>
</li>
<li><strong>互操作性</strong> <em>(crate 与其他库功能良好交互)</em>
<ul>
<li><input disabled="" type="checkbox"/>
类型积极实现常见特性 (<a href="interoperability.html#c-common-traits">C-COMMON-TRAITS</a>)
<ul>
<li><code>Copy</code>, <code>Clone</code>, <code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code>, <code>Hash</code>, <code>Debug</code>,
<code>Display</code>, <code>Default</code></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
转换使用标准特性 <code>From</code>, <code>AsRef</code>, <code>AsMut</code> (<a href="interoperability.html#c-conv-traits">C-CONV-TRAITS</a>)</li>
<li><input disabled="" type="checkbox"/>
集合实现 <code>FromIterator</code> 和 <code>Extend</code> (<a href="interoperability.html#c-collect">C-COLLECT</a>)</li>
<li><input disabled="" type="checkbox"/>
数据结构实现 Serde 的 <code>Serialize</code>, <code>Deserialize</code> (<a href="interoperability.html#c-serde">C-SERDE</a>)</li>
<li><input disabled="" type="checkbox"/>
类型在可能的情况下是 <code>Send</code> 和 <code>Sync</code> (<a href="interoperability.html#c-send-sync">C-SEND-SYNC</a>)</li>
<li><input disabled="" type="checkbox"/>
错误类型有意义且行为良好 (<a href="interoperability.html#c-good-err">C-GOOD-ERR</a>)</li>
<li><input disabled="" type="checkbox"/>
二进制数类型提供 <code>Hex</code>, <code>Octal</code>, <code>Binary</code> 格式化 (<a href="interoperability.html#c-num-fmt">C-NUM-FMT</a>)</li>
<li><input disabled="" type="checkbox"/>
通用读/写函数按值接收 <code>R: Read</code> 和 <code>W: Write</code> (<a href="interoperability.html#c-rw-value">C-RW-VALUE</a>)</li>
</ul>
</li>
<li><strong>宏</strong> <em>(crate 提供行为良好的宏)</em>
<ul>
<li><input disabled="" type="checkbox"/>
输入语法唤起输出 (<a href="macros.html#c-evocative">C-EVOCATIVE</a>)</li>
<li><input disabled="" type="checkbox"/>
宏与属性良好组合 (<a href="macros.html#c-macro-attr">C-MACRO-ATTR</a>)</li>
<li><input disabled="" type="checkbox"/>
项目宏在允许项目的任何地方工作 (<a href="macros.html#c-anywhere">C-ANYWHERE</a>)</li>
<li><input disabled="" type="checkbox"/>
项目宏支持可见性说明符 (<a href="macros.html#c-macro-vis">C-MACRO-VIS</a>)</li>
<li><input disabled="" type="checkbox"/>
类型片段灵活 (<a href="macros.html#c-macro-ty">C-MACRO-TY</a>)</li>
</ul>
</li>
<li><strong>文档</strong> <em>(crate 文档丰富)</em>
<ul>
<li><input disabled="" type="checkbox"/>
crate 级别文档详尽并包含示例 (<a href="documentation.html#c-crate-doc">C-CRATE-DOC</a>)</li>
<li><input disabled="" type="checkbox"/>
所有项目都有 rustdoc 示例 (<a href="documentation.html#c-example">C-EXAMPLE</a>)</li>
<li><input disabled="" type="checkbox"/>
示例使用 <code>?</code>，而不是 <code>try!</code> 或 <code>unwrap</code> (<a href="documentation.html#c-question-mark">C-QUESTION-MARK</a>)</li>
<li><input disabled="" type="checkbox"/>
函数文档包含错误、恐慌和安全性考虑 (<a href="documentation.html#c-failure">C-FAILURE</a>)</li>
<li><input disabled="" type="checkbox"/>
文章包含相关内容的超链接 (<a href="documentation.html#c-link">C-LINK</a>)</li>
<li><input disabled="" type="checkbox"/>
Cargo.toml 包含所有常见元数据 (<a href="documentation.html#c-metadata">C-METADATA</a>)
<ul>
<li>作者、描述、许可证、主页、文档、仓库、关键词、类别</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
发行说明记录所有重大变化 (<a href="documentation.html#c-relnotes">C-RELNOTES</a>)</li>
<li><input disabled="" type="checkbox"/>
Rustdoc 不显示无用的实现细节 (<a href="documentation.html#c-hidden">C-HIDDEN</a>)</li>
</ul>
</li>
<li><strong>可预测性</strong> <em>(crate 使代码易读且行为如表面所示)</em>
<ul>
<li><input disabled="" type="checkbox"/>
智能指针不添加固有方法 (<a href="predictability.html#c-smart-ptr">C-SMART-PTR</a>)</li>
<li><input disabled="" type="checkbox"/>
转换存在于所涉及的最具体类型上 (<a href="predictability.html#c-conv-specific">C-CONV-SPECIFIC</a>)</li>
<li><input disabled="" type="checkbox"/>
具有明确接收者的函数是方法 (<a href="predictability.html#c-method">C-METHOD</a>)</li>
<li><input disabled="" type="checkbox"/>
函数不接收输出参数 (<a href="predictability.html#c-no-out">C-NO-OUT</a>)</li>
<li><input disabled="" type="checkbox"/>
操作符重载不令人惊讶 (<a href="predictability.html#c-overload">C-OVERLOAD</a>)</li>
<li><input disabled="" type="checkbox"/>
只有智能指针实现 <code>Deref</code> 和 <code>DerefMut</code> (<a href="predictability.html#c-deref">C-DEREF</a>)</li>
<li><input disabled="" type="checkbox"/>
构造函数是静态的固有方法 (<a href="predictability.html#c-ctor">C-CTOR</a>)</li>
</ul>
</li>
<li><strong>灵活性</strong> <em>(crate 支持多样的现实使用场景)</em>
<ul>
<li><input disabled="" type="checkbox"/>
函数暴露中间结果以避免重复工作 (<a href="flexibility.html#c-intermediate">C-INTERMEDIATE</a>)</li>
<li><input disabled="" type="checkbox"/>
调用者决定在哪里复制和放置数据 (<a href="flexibility.html#c-caller-control">C-CALLER-CONTROL</a>)</li>
<li><input disabled="" type="checkbox"/>
函数通过使用泛型最小化对参数的假设 (<a href="flexibility.html#c-generic">C-GENERIC</a>)</li>
<li><input disabled="" type="checkbox"/>
如果特性作为特性对象可能有用，则它们是对象安全的 (<a href="flexibility.html#c-object">C-OBJECT</a>)</li>
</ul>
</li>
<li><strong>类型安全</strong> <em>(crate 有效利用类型系统)</em>
<ul>
<li><input disabled="" type="checkbox"/>
新类型提供静态区分 (<a href="type-safety.html#c-newtype">C-NEWTYPE</a>)</li>
<li><input disabled="" type="checkbox"/>
参数通过类型而不是 <code>bool</code> 或 <code>Option</code> 传达意义 (<a href="type-safety.html#c-custom-type">C-CUSTOM-TYPE</a>)</li>
<li><input disabled="" type="checkbox"/>
一组标志的类型是 <code>bitflags</code>，而不是枚举 (<a href="type-safety.html#c-bitflag">C-BITFLAG</a>)</li>
<li><input disabled="" type="checkbox"/>
构建器使复杂值的构建成为可能 (<a href="type-safety.html#c-builder">C-BUILDER</a>)</li>
</ul>
</li>
<li><strong>可靠性</strong> <em>(crate 不太可能做错事)</em>
<ul>
<li><input disabled="" type="checkbox"/>
函数验证其参数 (<a href="dependability.html#c-validate">C-VALIDATE</a>)</li>
<li><input disabled="" type="checkbox"/>
析构函数从不失败 (<a href="dependability.html#c-dtor-fail">C-DTOR-FAIL</a>)</li>
<li><input disabled="" type="checkbox"/>
可能阻塞的析构函数有替代方案 (<a href="dependability.html#c-dtor-block">C-DTOR-BLOCK</a>)</li>
</ul>
</li>
<li><strong>可调试性</strong> <em>(crate 便于调试)</em>
<ul>
<li><input disabled="" type="checkbox"/>
所有公共类型实现 <code>Debug</code> (<a href="debuggability.html#c-debug">C-DEBUG</a>)</li>
<li><input disabled="" type="checkbox"/>
<code>Debug</code> 表示永不为空 (<a href="debuggability.html#c-debug-nonempty">C-DEBUG-NONEMPTY</a>)</li>
</ul>
</li>
<li><strong>未来保障</strong> <em>(crate 可以在不破坏用户代码的情况下改进)</em>
<ul>
<li><input disabled="" type="checkbox"/>
密封特性防止下游实现 (<a href="future-proofing.html#c-sealed">C-SEALED</a>)</li>
<li><input disabled="" type="checkbox"/>
结构体有私有字段 (<a href="future-proofing.html#c-struct-private">C-STRUCT-PRIVATE</a>)</li>
<li><input disabled="" type="checkbox"/>
新类型封装实现细节 (<a href="future-proofing.html#c-newtype-hide">C-NEWTYPE-HIDE</a>)</li>
<li><input disabled="" type="checkbox"/>
数据结构不重复派生特性边界 (<a href="future-proofing.html#c-struct-bounds">C-STRUCT-BOUNDS</a>)</li>
</ul>
</li>
<li><strong>必要性</strong> <em>(对相关人员而言，它们非常重要)</em>
<ul>
<li><input disabled="" type="checkbox"/>
稳定 crate 的公共依赖是稳定的 (<a href="necessities.html#c-stable">C-STABLE</a>)</li>
<li><input disabled="" type="checkbox"/>
crate 及其依赖项具有宽松的许可证 (<a href="necessities.html#c-permissive">C-PERMISSIVE</a>)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名"><a class="header" href="#命名">命名</a></h1>
<p><a id="c-case"></a></p>
<h2 id="大小写遵循-rfc-430-c-case"><a class="header" href="#大小写遵循-rfc-430-c-case">大小写遵循 RFC 430 (C-CASE)</a></h2>
<p>基本的 Rust 命名约定在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 430</a> 中有描述。</p>
<p>一般来说，Rust 倾向于使用 <code>UpperCamelCase</code>（大驼峰命名法）用于“类型级”构造（类型和特征），使用 <code>snake_case</code>（蛇形命名法）用于“值级”构造。更准确地说：</p>
<div class="table-wrapper"><table><thead><tr><th>项目</th><th>约定</th></tr></thead><tbody>
<tr><td>Crates</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">不明确</a></td></tr>
<tr><td>Modules</td><td><code>snake_case</code></td></tr>
<tr><td>Types</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>Traits</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>Enum variants</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>Functions</td><td><code>snake_case</code></td></tr>
<tr><td>Methods</td><td><code>snake_case</code></td></tr>
<tr><td>General constructors</td><td><code>new</code> or <code>with_more_details</code></td></tr>
<tr><td>Conversion constructors</td><td><code>from_some_other_type</code></td></tr>
<tr><td>Macros</td><td><code>snake_case!</code></td></tr>
<tr><td>Local variables</td><td><code>snake_case</code></td></tr>
<tr><td>Statics</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>Constants</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>Type parameters</td><td>简洁的 <code>UpperCamelCase</code>，通常是单个大写字母：<code>T</code></td></tr>
<tr><td>Lifetimes</td><td>简短的 <code>lowercase</code>，通常是单个字母：<code>'a</code>，<code>'de</code>，<code>'src</code></td></tr>
<tr><td>Features</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/101">不明确</a> 但是见 <a href="naming.html#c-feature">C-FEATURE</a></td></tr>
</tbody></table>
</div>
<p>在 <code>UpperCamelCase</code> 中，缩略词和复合词的缩写算作一个词：使用 <code>Uuid</code> 而不是 <code>UUID</code>，<code>Usize</code> 而不是 <code>USize</code>，或 <code>Stdin</code> 而不是 <code>StdIn</code>。在 <code>snake_case</code> 中，缩略词和缩写则要小写：<code>is_xid_start</code>。</p>
<p>在 <code>snake_case</code> 或 <code>SCREAMING_SNAKE_CASE</code> 中，一个“单词”不应该只包含一个字母，除非它是最后一个“单词”。所以，我们有 <code>btree_map</code> 而不是 <code>b_tree_map</code>，但是有 <code>PI_2</code> 而不是 <code>PI2</code>。</p>
<p>Crate 名称不应使用 <code>-rs</code> 或 <code>-rust</code> 作为后缀或前缀。每个 crate 都是 Rust！没必要一直提醒用户这一点。</p>
<h3 id="标准库中的示例"><a class="header" href="#标准库中的示例">标准库中的示例</a></h3>
<p>整个标准库。这条准则应该很容易！</p>
<p><a id="c-conv"></a></p>
<h2 id="临时转换遵循-as_to_into_-约定-c-conv"><a class="header" href="#临时转换遵循-as_to_into_-约定-c-conv">临时转换遵循 <code>as_</code>，<code>to_</code>，<code>into_</code> 约定 (C-CONV)</a></h2>
<p>转换应该以方法的形式提供，其名称根据以下前缀命名：</p>
<div class="table-wrapper"><table><thead><tr><th>前缀</th><th>成本</th><th>所有权</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>免费</td><td>借用 -&gt; 借用</td></tr>
<tr><td><code>to_</code></td><td>昂贵</td><td>借用 -&gt; 借用<br>借用 -&gt; 拥有 (非 Copy 类型)<br>拥有 -&gt; 拥有 (Copy 类型)</td></tr>
<tr><td><code>into_</code></td><td>可变</td><td>拥有 -&gt; 拥有 (非 Copy 类型)</td></tr>
</tbody></table>
</div>
<p>例如：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 提供字符串作为一片 UTF-8 字节视图，这个操作是免费的。输入是借用的 <code>&amp;str</code>，输出是借用的 <code>&amp;[u8]</code>。</li>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str"><code>Path::to_str</code></a> 在操作系统路径的字节上执行昂贵的 UTF-8 检查。输入和输出都是借用的。称之为 <code>as_str</code> 在运行时有非琐碎的成本是不正确的。</li>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase"><code>str::to_lowercase()</code></a> 生成 <code>str</code> 的 Unicode 正确的小写版本，这涉及字符串字符的迭代并可能需要内存分配。输入是借用的 <code>&amp;str</code>，输出是拥有的 <code>String</code>。</li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians"><code>f64::to_radians()</code></a> 将浮点数从度转换为弧度。输入是 <code>f64</code>。传递引用 <code>&amp;f64</code> 是不必要的，因为 <code>f64</code> 的复制成本很低。称此函数为 <code>into_radians</code> 会产生误导，因为输入不会被消耗。</li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a> 提取 <code>String</code> 的底层 <code>Vec&lt;u8&gt;</code>，这是免费的。它获取 <code>String</code> 的所有权并返回拥有的 <code>Vec&lt;u8&gt;</code>。</li>
<li><a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader::into_inner()</code></a> 获取一个缓冲读取器的所有权，并提取出底层读取器，这是免费的。缓冲的数据会被丢弃。</li>
<li><a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner"><code>BufWriter::into_inner()</code></a> 获取一个缓冲写入器的所有权，并提取出底层写入器，这可能需要昂贵的刷新操作来处理任何缓冲数据。</li>
</ul>
<p>以 <code>as_</code> 和 <code>into_</code> 为前缀的转换通常 <em>降低抽象</em>，要么暴露对底层表示的视图（<code>as</code>），要么将数据分解为其底层表示（<code>into</code>）。而以 <code>to_</code> 为前缀的转换通常保持在同一抽象级别，但会进行一些工作以在表示之间进行转换。</p>
<p>当一个类型包装单个值以将其与更高级别的语义关联时，访问被包装的值应通过 <code>into_inner()</code> 方法提供。这适用于提供缓冲的包装器，如 <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a>，编码或解码如 <a href="https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>，原子访问如 <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a>，或任何类似语义的情况。</p>
<p>如果转换方法名称中的 <code>mut</code> 修饰符是返回类型的一部分，则其应如同其在类型中出现的方式出现。例如 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 返回 mut 切片；它名副其实。该名称优于 <code>as_slice_mut</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 返回类型是一个可变切片。
fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
<span class="boring">}</span></code></pre></pre>
<h5 id="更多标准库的示例"><a class="header" href="#更多标准库的示例">更多标准库的示例</a></h5>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<p><a id="c-getter"></a></p>
<h2 id="getter-名称遵循-rust-约定-c-getter"><a class="header" href="#getter-名称遵循-rust-约定-c-getter">Getter 名称遵循 Rust 约定 (C-GETTER)</a></h2>
<p>除少数例外，Rust 代码中的 getter 不使用 <code>get_</code> 前缀。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 不是 get_first。
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 不是 get_first_mut、get_mut_first 或 mut_first。
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>get</code> 命名仅在有单一且明显的东西可以通过 getter 获得时使用。例如 <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get"><code>Cell::get</code></a> 用于访问 <code>Cell</code> 的内容。</p>
<p>对于进行运行时验证（如边界检查）的 getter，考虑添加不安全的 <code>_unchecked</code> 变体。通常这些方法具有以下签名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}</span></code></pre></pre>
<p>getters 和转换 (<a href="naming.html#c-conv">C-CONV</a>) 之间的区别可能很微妙，并不总是很明确。例如 <a href="https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a> 可以被理解为临时目录的文件系统路径的 getter，而 <a href="https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.into_path"><code>TempDir::into_path</code></a> 是一种转换，将删除临时目录的责任转移给调用者。由于 <code>path</code> 是一个 getter，将其称为 <code>get_path</code> 或 <code>as_path</code> 是不正确的。</p>
<h3 id="标准库的示例"><a class="header" href="#标准库的示例">标准库的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<p><a id="c-iter"></a></p>
<h2 id="生成迭代器的方法遵循-iteriter_mutinto_iter-约定-c-iter"><a class="header" href="#生成迭代器的方法遵循-iteriter_mutinto_iter-约定-c-iter">生成迭代器的方法遵循 <code>iter</code>，<code>iter_mut</code>，<code>into_iter</code> 约定 (C-ITER)</a></h2>
<p>根据 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md">RFC 199</a>。</p>
<p>对于包含元素类型 <code>U</code> 的容器，迭代器方法应被命名为：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iter(&amp;self) -&gt; Iter             // Iter 实现了 Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut 实现了 Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter 实现了 Iterator&lt;Item = U&gt;
<span class="boring">}</span></code></pre></pre>
<p>此准则适用于概念上同质集合的数据结构。作为反例，<code>str</code> 类型是一片保证为有效 UTF-8 的字节。这在概念上比同质集合更为复杂，因此它没有提供 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 一组迭代器方法，而是提供了 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.bytes"><code>str::bytes</code></a> 以字节迭代和 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a> 以字符迭代。</p>
<p>这一准则只适用于方法，而不适用于函数。例如，<code>url</code> crate 中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a> 返回一个迭代器，具有对百分编码字符串片段的迭代功能。使用 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 约定并不会带来清晰性。</p>
<h3 id="标准库的示例-1"><a class="header" href="#标准库的示例-1">标准库的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
</ul>
<p><a id="c-iter-ty"></a></p>
<h2 id="迭代器类型名称与生成它们的方法匹配-c-iter-ty"><a class="header" href="#迭代器类型名称与生成它们的方法匹配-c-iter-ty">迭代器类型名称与生成它们的方法匹配 (C-ITER-TY)</a></h2>
<p>名为 <code>into_iter()</code> 的方法应返回一个名为 <code>IntoIter</code> 的类型，而其他所有返回迭代器的方法也是如此。</p>
<p>这一准则主要适用于方法，但通常也对函数适用。例如，<code>url</code> crate 中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a> 函数返回一个名为 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html"><code>PercentEncode</code></a> 的迭代器类型。</p>
<p>这些类型名称在其所属模块的前缀下最有意义，例如 <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>vec::IntoIter</code></a>。</p>
<h3 id="标准库的示例-2"><a class="header" href="#标准库的示例-2">标准库的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a> 返回 <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html"><code>Iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a> 返回 <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html"><code>IterMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a> 返回 <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>IntoIter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a> 返回 <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html"><code>Keys</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> 返回 <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html"><code>Values</code></a></li>
</ul>
<p><a id="c-feature"></a></p>
<h2 id="功能名称不应包含占位符词语-c-feature"><a class="header" href="#功能名称不应包含占位符词语-c-feature">功能名称不应包含占位符词语 (C-FEATURE)</a></h2>
<p>不要在 <a href="http://doc.crates.io/manifest.html#the-features-section">Cargo 功能</a> 的名称中包含无意义的词，比如 <code>use-abc</code> 或 <code>with-abc</code>。直接将功能命名为 <code>abc</code>。</p>
<p>这在对 Rust 标准库有可选依赖的 crate 中尤为普遍。正确的做法是：</p>
<pre><code class="language-toml"># 在 Cargo.toml 中

[features]
default = ["std"]
std = []
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在 lib.rs 中
#![no_std]

#[cfg(feature = "std")]
extern crate std;
<span class="boring">}</span></code></pre></pre>
<p>不要将功能命名为 <code>use-std</code> 或 <code>with-std</code>，或其他不具创意且不是 <code>std</code> 的名字。这种命名约定与 Cargo 为可选依赖推断的隐式功能命名一致。考虑 crate <code>x</code> 对 Serde 和 Rust 标准库的可选依赖：</p>
<pre><code class="language-toml">[package]
name = "x"
version = "0.1.0"

[features]
std = ["serde/std"]

[dependencies]
serde = { version = "1.0", optional = true }
</code></pre>
<p>当我们依赖 <code>x</code> 时，可以通过 <code>features = ["serde"]</code> 启用可选 Serde 依赖。同样地，我们可以通过 <code>features = ["std"]</code> 启用可选标准库依赖。Cargo 为可选依赖推断的隐式功能名为 <code>serde</code>，而不是 <code>use-serde</code> 或 <code>with-serde</code>，因此我们希望显式功能以相同方式工作。</p>
<p>另外需要注意的是，Cargo 要求功能是增量性的，因此像 <code>no-abc</code> 这样的负面命名几乎从来都不正确。</p>
<p><a id="c-word-order"></a></p>
<h2 id="名称使用一致的词序-c-word-order"><a class="header" href="#名称使用一致的词序-c-word-order">名称使用一致的词序 (C-WORD-ORDER)</a></h2>
<p>以下是标准库中的一些错误类型：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>以上所有都使用了动词-对象-错误词序。如果我们要添加一个表示地址解析失败的错误，为了一致性，我们应该按照动词-对象-错误词序命名它为 <code>ParseAddrError</code>，而不是 <code>AddrParseError</code>。</p>
<p>特定的词序选择并不重要，但要注意内部的统一性，以及与标准库中类似功能的一致性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="互操作性"><a class="header" href="#互操作性">互操作性</a></h1>
<p><a id="c-common-traits"></a></p>
<h2 id="类型应尽早实现常见的-traitc-common-traits"><a class="header" href="#类型应尽早实现常见的-traitc-common-traits">类型应尽早实现常见的 trait（C-COMMON-TRAITS）</a></h2>
<p>Rust 的 trait 系统不允许存在“孤儿”：大致上，每个 <code>impl</code> 必须存在于定义该 trait 的 crate 或实现该类型的 crate 中。因此，定义新类型的 crate 应该尽早实现所有适用的常见 trait。</p>
<p>为了理解这一点，请考虑以下情况：</p>
<ul>
<li>Crate <code>std</code> 定义了 trait <code>Display</code>。</li>
<li>Crate <code>url</code> 定义了类型 <code>Url</code>，但没有实现 <code>Display</code>。</li>
<li>Crate <code>webapp</code> 从 <code>std</code> 和 <code>url</code> 中导入了内容。</li>
</ul>
<p>由于 <code>webapp</code> 既不定义 <code>Display</code> 也不定义 <code>Url</code>，因此它无法为 <code>Url</code> 添加 <code>Display</code>。 （注意：newtype 模式可以提供一种有效但不便的解决方法。）</p>
<p>最重要的常见 trait 实现来自 <code>std</code>：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a></li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a></li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></li>
</ul>
<p>请注意，通常类型同时实现 <code>Default</code> 和空的 <code>new</code> 构造函数是常见且预期的。<code>new</code> 是 Rust 中的构造函数惯例，用户希望它存在，所以如果基本构造函数不需要参数，那么即使它与 <code>default</code> 功能相同，也应该存在。</p>
<p><a id="c-conv-traits"></a></p>
<h2 id="转换使用标准的-fromasrefasmut-traitc-conv-traits"><a class="header" href="#转换使用标准的-fromasrefasmut-traitc-conv-traits">转换使用标准的 <code>From</code>、<code>AsRef</code>、<code>AsMut</code> trait（C-CONV-TRAITS）</a></h2>
<p>在合适的情况下，应该实现以下转换 trait：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a></li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a></li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a></li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a></li>
</ul>
<p>以下转换 trait 不应被实现：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a></li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a></li>
</ul>
<p>这些 trait 基于 <code>From</code> 和 <code>TryFrom</code> 提供了通用实现。应优先实现这些。</p>
<h3 id="标准库中的示例-1"><a class="header" href="#标准库中的示例-1">标准库中的示例</a></h3>
<ul>
<li><code>From&lt;u16&gt;</code> 实现了 <code>u32</code>，因为较小的整数总是可以转换为较大的整数。</li>
<li><code>From&lt;u32&gt;</code> 并未为 <code>u16</code> 实现，因为如果整数太大，转换可能无法完成。</li>
<li><code>TryFrom&lt;u32&gt;</code> 为 <code>u16</code> 实现，当整数太大而无法容纳在 <code>u16</code> 中时返回错误。</li>
<li><a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html"><code>From&lt;Ipv6Addr&gt;</code></a> 实现了 <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html"><code>IpAddr</code></a>，它是一种可以表示 v4 和 v6 IP 地址的类型。</li>
</ul>
<p><a id="c-collect"></a></p>
<h2 id="集合实现-fromiterator-和-extendc-collect"><a class="header" href="#集合实现-fromiterator-和-extendc-collect">集合实现 <code>FromIterator</code> 和 <code>Extend</code>（C-COLLECT）</a></h2>
<p><a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> 和 <a href="https://doc.rust-lang.org/std/iter/trait.Extend.html"><code>Extend</code></a> 使集合可以方便地与以下迭代器方法一起使用：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>Iterator::collect</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition"><code>Iterator::partition</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.unzip"><code>Iterator::unzip</code></a></li>
</ul>
<p><code>FromIterator</code> 用于创建一个包含迭代器中项的新集合，而 <code>Extend</code> 则用于将迭代器中的项添加到现有集合中。</p>
<h3 id="标准库中的示例-2"><a class="header" href="#标准库中的示例-2">标准库中的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 实现了 <code>FromIterator&lt;T&gt;</code> 和 <code>Extend&lt;T&gt;</code>。</li>
</ul>
<p><a id="c-serde"></a></p>
<h2 id="数据结构实现-serde-的-serialize-和-deserializec-serde"><a class="header" href="#数据结构实现-serde-的-serialize-和-deserializec-serde">数据结构实现 Serde 的 <code>Serialize</code> 和 <code>Deserialize</code>（C-SERDE）</a></h2>
<p>扮演数据结构角色的类型应实现 <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> 和 <a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>Deserialize</code></a>。</p>
<p>从数据结构到非数据结构存在一个连续体，其中有一部分是灰色区域。<a href="https://docs.rs/linked-hash-map/0.4.2/linked_hash_map/struct.LinkedHashMap.html"><code>LinkedHashMap</code></a> 和 <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html"><code>IpAddr</code></a> 是数据结构。有人希望从 JSON 文件中读取 <code>LinkedHashMap</code> 或 <code>IpAddr</code>，或者通过 IPC 将其发送到另一个进程，这是完全合理的。而 <a href="https://docs.rs/byteorder/1.0.0/byteorder/enum.LittleEndian.html"><code>LittleEndian</code></a> 不是数据结构。它是 <code>byteorder</code> crate 使用的一种标记，用于在编译时针对特定字节顺序进行优化，实际上 <code>LittleEndian</code> 的实例在运行时永远不会存在。这些是明确的例子；#rust 或 #serde IRC 频道可以帮助评估更多模棱两可的情况。</p>
<p>如果一个 crate 没有因为其他原因依赖于 Serde，它可以选择通过 Cargo 配置选项来控制 Serde 的实现。这样，下游库只需要在需要这些实现时支付编译 Serde 的代价。</p>
<p>为了与其他基于 Serde 的库保持一致，Cargo 配置的名称应为 <code>"serde"</code>。不要使用 <code>serde_impls</code> 或 <code>serde_serialization</code> 等不同的名称。</p>
<p>在不使用派生的情况下，规范的实现看起来像这样：</p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1.0", optional = true }
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct T { /* ... */ }

#[cfg(feature = "serde")]
impl Serialize for T { /* ... */ }

#[cfg(feature = "serde")]
impl&lt;'de&gt; Deserialize&lt;'de&gt; for T { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>使用派生时：</p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1.0", optional = true, features = ["derive"] }
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct T { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p><a id="c-send-sync"></a></p>
<h2 id="类型在可能的情况下实现-send-和-syncc-send-sync"><a class="header" href="#类型在可能的情况下实现-send-和-syncc-send-sync">类型在可能的情况下实现 <code>Send</code> 和 <code>Sync</code>（C-SEND-SYNC）</a></h2>
<p>当编译器确定合适时，<code>Send</code> 和 <code>Sync</code> 会自动实现。</p>
<p>在操作原始指针的类型中，要谨慎确保你的类型的 <code>Send</code> 和 <code>Sync</code> 状态准确反映其线程安全特性。类似于以下的测试可以帮助捕捉类型是否实现 <code>Send</code> 或 <code>Sync</code> 的非预期回归。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_send() {
    fn assert_send&lt;T: Send&gt;() {}
    assert_send::&lt;MyStrangeType&gt;();
}

#[test]
fn test_sync() {
    fn assert_sync&lt;T: Sync&gt;() {}
    assert_sync::&lt;MyStrangeType&gt;();
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-good-err"></a></p>
<h2 id="错误类型应具有意义且表现良好c-good-err"><a class="header" href="#错误类型应具有意义且表现良好c-good-err">错误类型应具有意义且表现良好（C-GOOD-ERR）</a></h2>
<p>错误类型是任何 <code>Result&lt;T, E&gt;</code> 中的 <code>E</code> 类型，它由你的 crate 的任何公共函数返回。错误类型应始终实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> trait，这是错误处理库如 <a href="https://docs.rs/error-chain"><code>error-chain</code></a> 抽象不同错误类型的机制，并且允许错误作为另一个错误的 <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source"><code>source()</code></a>。</p>
<p>此外，错误类型应实现 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> 和 <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> trait</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<p><a id="c-evocative"></a></p>
<h2 id="输入语法能引发对输出的联想-c-evocative"><a class="header" href="#输入语法能引发对输出的联想-c-evocative">输入语法能引发对输出的联想 (C-EVOCATIVE)</a></h2>
<p>Rust 宏允许你设计出几乎任何形式的输入语法。尽量保持输入语法与用户代码中其他部分一致，通过尽可能地模仿现有的 Rust 语法，使其更具亲和力和连贯性。注意关键词和标点符号的选择与放置。</p>
<p>一个好的指引是使用类似于宏输出结果的语法，特别是关键词和标点符号。</p>
<p>例如，如果你的宏在输入中声明了一个具有特定名称的结构体，请在该名称前加上关键词 <code>struct</code>，以向读者标明正在定义一个具有给定名称的结构体。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 优先这样写...
bitflags! {
    struct S: u32 { /* ... */ }
}

// ...而不是省略关键词...
bitflags! {
    S: u32 { /* ... */ }
}

// ...或使用随意的词。
bitflags! {
    flags S: u32 { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p>另一个例子是分号 vs 逗号。在 Rust 中，常量后用分号，所以如果你的宏声明了一连串常量，即使语法略有不同，也应当使用分号。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 普通常量使用分号。
const A: u32 = 0b000001;
const B: u32 = 0b000010;

// 所以更建议这样写...
bitflags! {
    struct S: u32 {
        const C = 0b000100;
        const D = 0b001000;
    }
}

// ...而不是这样。
bitflags! {
    struct S: u32 {
        const E = 0b010000,
        const F = 0b100000,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>宏的多样性使得这些具体例子可能不适用，但请考虑如何在你的情况下运用相同的原则。</p>
<p><a id="c-macro-attr"></a></p>
<h2 id="项目宏与属性很好地组合-c-macro-attr"><a class="header" href="#项目宏与属性很好地组合-c-macro-attr">项目宏与属性很好地组合 (C-MACRO-ATTR)</a></h2>
<p>生成多个输出项目的宏应支持为任何一个输出项目添加属性。一个常见的用法是通过 cfg 置于单个项目后。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags! {
    struct Flags: u8 {
        #[cfg(windows)]
        const ControlCenter = 0b001;
        #[cfg(unix)]
        const Terminal = 0b010;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>生成结构体或枚举作为输出的宏应该支持属性，以便输出可以与派生属性一起使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags! {
    #[derive(Default, Serialize)]
    struct Flags: u8 {
        const ControlCenter = 0b001;
        const Terminal = 0b010;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-anywhere"></a></p>
<h2 id="项目宏可在任何允许放置项目的地方运行-c-anywhere"><a class="header" href="#项目宏可在任何允许放置项目的地方运行-c-anywhere">项目宏可在任何允许放置项目的地方运行 (C-ANYWHERE)</a></h2>
<p>Rust 允许项目放置在模块级别或更紧凑的范围内，如函数内。项目宏应该在这些地方与普通项目一样正常工作。测试套件应包括在至少模块范围和函数范围内调用宏的情况。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    test_your_macro_in_a!(module);

    #[test]
    fn anywhere() {
        test_your_macro_in_a!(function);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>一个简单的错误示例是，这个宏在模块范围内工作良好，但在函数范围内失败。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! broken {
    ($m:ident :: $t:ident) =&gt; {
        pub struct $t;
        pub mod $m {
            pub use super::$t;
        }
    }
}

broken!(m::T); // 好的，展开为 T 和 m::T

fn g() {
    broken!(m::U); // 编译失败，super::U 指向的是包含的模块而不是 g
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-macro-vis"></a></p>
<h2 id="项目宏支持可见性说明符-c-macro-vis"><a class="header" href="#项目宏支持可见性说明符-c-macro-vis">项目宏支持可见性说明符 (C-MACRO-VIS)</a></h2>
<p>遵循 Rust 语法，宏生成的项目默认是私有的，如果指定 <code>pub</code> 则是公有的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags! {
    struct PrivateFlags: u8 {
        const A = 0b0001;
        const B = 0b0010;
    }
}

bitflags! {
    pub struct PublicFlags: u8 {
        const C = 0b0100;
        const D = 0b1000;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-macro-ty"></a></p>
<h2 id="类型片段是灵活的-c-macro-ty"><a class="header" href="#类型片段是灵活的-c-macro-ty">类型片段是灵活的 (C-MACRO-TY)</a></h2>
<p>如果你的宏在输入中接受类型片段如 <code>$t:ty</code>，它应能与以下所有内容一起使用：</p>
<ul>
<li>基本类型：<code>u8</code>，<code>&amp;str</code></li>
<li>相对路径：<code>m::Data</code></li>
<li>绝对路径：<code>::base::Data</code></li>
<li>向上相对路径：<code>super::Data</code></li>
<li>泛型：<code>Vec&lt;String&gt;</code></li>
</ul>
<p>一个简单的错误示例是，这个宏在使用基本类型和绝对路径时工作良好，但在使用相对路径时失败。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! broken {
    ($m:ident =&gt; $t:ty) =&gt; {
        pub mod $m {
            pub struct Wrapper($t);
        }
    }
}

broken!(a =&gt; u8); // 好的

broken!(b =&gt; ::std::marker::PhantomData&lt;()&gt;); // 好的

struct S;
broken!(c =&gt; S); // 编译失败
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文档"><a class="header" href="#文档">文档</a></h1>
<p><a id="c-crate-doc"></a></p>
<h2 id="crate-级别的文档应详尽并包含示例-c-crate-doc"><a class="header" href="#crate-级别的文档应详尽并包含示例-c-crate-doc">crate 级别的文档应详尽并包含示例 (C-CRATE-DOC)</a></h2>
<p>请参阅 <a href="https://github.com/rust-lang/rfcs/pull/1687">RFC 1687</a>。</p>
<p><a id="c-example"></a></p>
<h2 id="所有条目都应有一个-rustdoc-示例-c-example"><a class="header" href="#所有条目都应有一个-rustdoc-示例-c-example">所有条目都应有一个 rustdoc 示例 (C-EXAMPLE)</a></h2>
<p>每个公共模块、trait、struct、enum、函数、方法、宏和类型定义都应有一个示例来展示其功能。</p>
<p>该指南应在合理的范围内应用。</p>
<p>链接到另一个条目的相关示例可能是足够的。例如，如果只有一个函数使用了某个特定类型，那么在该函数或类型上编写一个示例并从另一个条目中链接到它可能是合适的。</p>
<p>示例的目的并不总是为了展示<em>如何使用</em>该条目。读者可以预期能够理解如何调用函数、匹配枚举以及其他基础任务。相反，示例通常是为了展示<em>为什么有人会想要使用</em>该条目。</p>
<pre><pre class="playground"><code class="language-rust">// 这是一个使用 clone() 的糟糕示例。它机械地展示了*如何*调用 clone()，但没有展示*为什么*有人会需要这样做。
fn main() {
    let hello = "hello";

    hello.clone();
}</code></pre></pre>
<p><a id="c-question-mark"></a></p>
<h2 id="示例应使用-而不是-try也不是-unwrap-c-question-mark"><a class="header" href="#示例应使用-而不是-try也不是-unwrap-c-question-mark">示例应使用 <code>?</code>，而不是 <code>try!</code>，也不是 <code>unwrap</code> (C-QUESTION-MARK)</a></h2>
<p>无论喜不喜欢，用户通常会逐字逐句地复制示例代码。解包错误（unwrap）应是用户需要自行做出的有意识决策。</p>
<p>编写可能失败的示例代码的一个常见结构如下所示。以 <code>#</code> 开头的行在构建示例时由 <code>cargo test</code> 编译，但不会出现在用户可见的 rustdoc 中。</p>
<pre><code>/// ```rust
/// # use std::error::Error;
/// #
/// # fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
/// your;
/// example?;
/// code;
/// #
/// #     Ok(())
/// # }
/// ```
</code></pre>
<p><a id="c-failure"></a></p>
<h2 id="函数文档应包含错误panic-和安全性考虑-c-failure"><a class="header" href="#函数文档应包含错误panic-和安全性考虑-c-failure">函数文档应包含错误、panic 和安全性考虑 (C-FAILURE)</a></h2>
<p>错误情况应在“Errors”部分中记录。这也适用于 trait 方法——对于那些允许或预期返回错误的实现，应该在“Errors”部分中进行记录。</p>
<p>例如，在标准库中，某些 <a href="https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read"><code>std::io::Read::read</code></a> trait 方法的实现可能会返回错误。</p>
<pre><code>/// 从该源中读取一些字节到指定的缓冲区中，并返回读取的字节数。
///
/// ... 更多信息 ...
///
/// # Errors
///
/// 如果此函数遇到任何形式的 I/O 或其他错误，将返回一个错误变体。如果返回错误，则必须确保没有字节被读取。
</code></pre>
<p>panic 情况应在“Panics”部分中记录。这也适用于 trait 方法——对于那些允许或预期会 panic 的实现，应在“Panics”部分中进行记录。</p>
<p>在标准库中，<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.insert"><code>Vec::insert</code></a> 方法可能会 panic。</p>
<pre><code>/// 在向量中的 `index` 位置插入一个元素，并将其后的所有元素向右移动。
///
/// # Panics
///
/// 如果 `index` 超出范围，将会 panic。
</code></pre>
<p>没有必要记录所有可能的 panic 情况，尤其是在 panic 发生在调用者提供的逻辑中。例如，记录以下代码中的 <code>Display</code> panic 似乎是多余的。但在不确定的情况下，宁可多记录 panic 情况。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Panics
///
/// 如果 `T` 的 `Display` 实现 panic，该函数将 panic。
pub fn print&lt;T: Display&gt;(t: T) {
    println!("{}", t.to_string());
}
<span class="boring">}</span></code></pre></pre>
<p>不安全函数应在“Safety”部分中记录，解释调用者在正确使用该函数时需要遵守的所有不变性。</p>
<p>不安全的 <a href="https://doc.rust-lang.org/std/ptr/fn.read.html"><code>std::ptr::read</code></a> 要求调用者遵守以下规则。</p>
<pre><code>/// 从 `src` 读取值，而不移动它。这将保持 `src` 中的内存不变。
///
/// # Safety
///
/// 除了接受一个原始指针外，这个函数是不安全的，因为它在语义上将值从 `src` 中移出，而不阻止 `src` 的进一步使用。
/// 如果 `T` 不是 `Copy`，则必须确保在数据被再次覆盖之前（例如使用 `write`、`zero_memory` 或 `copy_memory`），不要使用 `src` 中的值。请注意，`*src = foo` 也算作使用，因为它将尝试删除之前在 `*src` 处的值。
///
/// 指针必须对齐；如果不是这种情况，请使用 `read_unaligned`。
</code></pre>
<p><a id="c-link"></a></p>
<h2 id="文章中应包含到相关内容的超链接-c-link"><a class="header" href="#文章中应包含到相关内容的超链接-c-link">文章中应包含到相关内容的超链接 (C-LINK)</a></h2>
<p>常规链接可以使用通常的 Markdown 语法 <code>[text](url)</code> 内联添加。可以通过使用 <code>[`text`]</code> 标记的方式添加到其他类型的链接，然后在文档字符串末尾用 <code>[`text`]: &lt;target&gt;</code> 添加链接目标，其中 <code>&lt;target&gt;</code> 如下所述。</p>
<p>指向同一类型中的方法的链接目标通常如下所示：</p>
<pre><code class="language-md">[`serialize_struct`]: #method.serialize_struct
</code></pre>
<p>指向其他类型的链接目标通常如下所示：</p>
<pre><code class="language-md">[`Deserialize`]: trait.Deserialize.html
</code></pre>
<p>链接目标也可以指向父模块或子模块：</p>
<pre><code class="language-md">[`Value`]: ../enum.Value.html
[`DeserializeOwned`]: de/trait.DeserializeOwned.html
</code></pre>
<p>此指南由 RFC 1574 正式推荐，标题为 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md#link-all-the-things">"Link all the things"</a>。</p>
<p><a id="c-metadata"></a></p>
<h2 id="cargotoml-应包含所有常见的元数据-c-metadata"><a class="header" href="#cargotoml-应包含所有常见的元数据-c-metadata">Cargo.toml 应包含所有常见的元数据 (C-METADATA)</a></h2>
<p><code>Cargo.toml</code> 的 <code>[package]</code> 部分应包括以下值：</p>
<ul>
<li><code>authors</code></li>
<li><code>description</code></li>
<li><code>license</code></li>
<li><code>repository</code></li>
<li><code>keywords</code></li>
<li><code>categories</code></li>
</ul>
<p>此外，还有两个可选的元数据字段：</p>
<ul>
<li><code>documentation</code></li>
<li><code>homepage</code></li>
</ul>
<p>默认情况下，<em>crates.io</em> 会链接到 <a href="https://docs.rs"><em>docs.rs</em></a> 上的 crate 文档。只有当文档托管在 <em>docs.rs</em> 以外的地方时，才需要设置 <code>documentation</code> 元数据，例如因为 crate 链接到 <em>docs.rs</em> 构建环境中不可用的共享库。</p>
<p>只有当 crate 有一个独立于源代码仓库或 API 文档的独特网站时，才应设置 <code>homepage</code> 元数据。不要让 <code>homepage</code> 与 <code>documentation</code> 或 <code>repository</code> 值重复。例如，serde 将 <code>homepage</code> 设置为 <em>https://serde.rs</em>，这是一个专用网站。</p>
<p><a id="c-relnotes"></a></p>
<h2 id="发布说明应记录所有重要更改-c-relnotes"><a class="header" href="#发布说明应记录所有重要更改-c-relnotes">发布说明应记录所有重要更改 (C-RELNOTES)</a></h2>
<p>crate 的用户可以阅读发布说明以找到每个发布版本中的更改摘要。发布说明的链接或发布说明本身应包含在 crate 级文档和/或 Cargo.toml 中链接的仓库中。</p>
<p>发布说明中应清楚标识破坏性更改（根据 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md">RFC 1105</a> 定义）。</p>
<p>如果使用 Git 来跟踪 crate 的源代码，则发布到 <em>crates.io</em> 的每个版本都应有一个对应的标签，标识已发布的提交。对于非 Git 的版本控制工具，也应采用类似的流程。</p>
<pre><code class="language-bash"># 标记当前提交
GIT_COMMITTER_DATE=$(git log -n1 --pretty=%aD) git tag -a -m "Release 0.3.0" 0.3.0
git push --tags
</code></pre>
<p>推荐使用带注释的标签，因为如果存在带注释的标签，有些 Git 命令会忽略未注释的标签。</p>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<ul>
<li><a href="https://github.com/serde-rs/serde/releases/tag/v1.0.0">Serde 1.0.0 发布说明</a></li>
<li><a href="https://github.com/serde-rs/serde/releases/tag/v0.9.8">Serde 0.9.8 发布说明</a></li>
<li><a href="https://github.com/serde-rs/serde/releases/tag/v0.9.0">Serde 0.9.0 发布说明</a></li>
<li><a href="https://github.com/diesel-rs/diesel/blob/master/CHANGELOG.md">Diesel 变更日志</a></li>
</ul>
<p><a id="c-hidden"></a></p>
<h2 id="rustdoc-不应显示无用的实现细节-c-hidden"><a class="header" href="#rustdoc-不应显示无用的实现细节-c-hidden">Rustdoc 不应显示无用的实现细节 (C-HIDDEN)</a></h2>
<p>Rustdoc 应该包含用户完整使用 crate 所需的所有内容，但不应包含更多内容</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可预测性"><a class="header" href="#可预测性">可预测性</a></h1>
<p><a id="c-smart-ptr"></a></p>
<h2 id="智能指针不添加固有方法-c-smart-ptr"><a class="header" href="#智能指针不添加固有方法-c-smart-ptr">智能指针不添加固有方法 (C-SMART-PTR)</a></h2>
<p>例如，这就是 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"><code>Box::into_raw</code></a> 函数定义方式的原因。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Box&lt;T&gt; where T: ?Sized {
    fn into_raw(b: Box&lt;T&gt;) -&gt; *mut T { /* ... */ }
}

let boxed_str: Box&lt;str&gt; = /* ... */;
let ptr = Box::into_raw(boxed_str);
<span class="boring">}</span></code></pre></pre>
<p>如果将其定义为一个固有方法，那么在调用点就会产生混淆，不知道被调用的方法是 <code>Box&lt;T&gt;</code> 上的方法还是 <code>T</code> 上的方法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Box&lt;T&gt; where T: ?Sized {
    // 不要这样做。
    fn into_raw(self) -&gt; *mut T { /* ... */ }
}

let boxed_str: Box&lt;str&gt; = /* ... */;

// 这是通过智能指针 Deref 实现访问的 str 上的方法。
boxed_str.chars()

// 这是 Box&lt;str&gt; 上的方法...?
boxed_str.into_raw()
<span class="boring">}</span></code></pre></pre>
<p><a id="c-conv-specific"></a></p>
<h2 id="转换发生在涉及的最具体的类型上-c-conv-specific"><a class="header" href="#转换发生在涉及的最具体的类型上-c-conv-specific">转换发生在涉及的最具体的类型上 (C-CONV-SPECIFIC)</a></h2>
<p>在有疑问时，优先使用 <code>to_</code>/<code>as_</code>/<code>into_</code> 而不是 <code>from_</code>，因为它们更符合使用习惯（并且可以与其他方法链式调用）。</p>
<p>对于两种类型之间的许多转换，其中一种类型显然更加“具体”：它提供了一些在其他类型中不存在的附加不变性或解释。例如，<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a> 比 <code>&amp;[u8]</code> 更具体，因为它是一个 UTF-8 编码的字节序列。</p>
<p>转换应当存在于涉及的类型中更具体的那个上。因此，<code>str</code> 提供了 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>as_bytes</code></a> 方法和 <a href="https://doc.rust-lang.org/std/str/fn.from_utf8.html"><code>from_utf8</code></a> 构造器用于与 <code>&amp;[u8]</code> 值之间的转换。除了直观之外，这种约定还避免了使用具体类型如 <code>&amp;[u8]</code> 被无穷尽的转换方法污染。</p>
<p><a id="c-method"></a></p>
<h2 id="具有明确接收对象的函数是方法-c-method"><a class="header" href="#具有明确接收对象的函数是方法-c-method">具有明确接收对象的函数是方法 (C-METHOD)</a></h2>
<p>倾向于</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
    pub fn frob(&amp;self, w: widget) { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p>而非</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn frob(foo: &amp;Foo, w: widget) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>用于任何明显与特定类型关联的操作。</p>
<p>方法相较于函数有很多优势：</p>
<ul>
<li>它们不需要导入或限定即可使用：你只需要一个合适类型的值。</li>
<li>它们的调用执行自动借用（包括可变借用）。</li>
<li>它们使回答“我可以用类型 <code>T</code> 的值做什么”这一问题变得容易（特别是在使用 rustdoc 时）。</li>
<li>它们提供 <code>self</code> 表示法，更简洁且通常更清晰地传达所有权区别。</li>
</ul>
<p><a id="c-no-out"></a></p>
<h2 id="函数不接受输出参数-c-no-out"><a class="header" href="#函数不接受输出参数-c-no-out">函数不接受输出参数 (C-NO-OUT)</a></h2>
<p>倾向于</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; (Bar, Bar)
<span class="boring">}</span></code></pre></pre>
<p>而非</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(output: &amp;mut Bar) -&gt; Bar
<span class="boring">}</span></code></pre></pre>
<p>用于返回多个 <code>Bar</code> 值。</p>
<p>诸如元组和结构体的复合返回类型编译得非常高效，不需要堆分配。如果一个函数需要返回多个值，应通过这些类型之一来返回。</p>
<p>主要的例外情况：有时候函数旨在修改调用者已经拥有的数据，例如重用一个缓冲区：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt;
<span class="boring">}</span></code></pre></pre>
<p><a id="c-overload"></a></p>
<h2 id="操作符重载应不令人惊讶-c-overload"><a class="header" href="#操作符重载应不令人惊讶-c-overload">操作符重载应不令人惊讶 (C-OVERLOAD)</a></h2>
<p>带有内建语法（<code>*</code>, <code>|</code>, 等）的操作符可以通过实现 <a href="https://doc.rust-lang.org/std/ops/index.html#traits"><code>std::ops</code></a> 中的特征为类型提供。这些操作符伴随着强烈的期望：仅为与乘法有某种相似性的运算（并共享期望的属性, 如结合律）实现 <code>Mul</code>，其他特征同理。</p>
<p><a id="c-deref"></a></p>
<h2 id="只有智能指针实现-deref-和-derefmut-c-deref"><a class="header" href="#只有智能指针实现-deref-和-derefmut-c-deref">只有智能指针实现 <code>Deref</code> 和 <code>DerefMut</code> (C-DEREF)</a></h2>
<p><code>Deref</code> 特征在很多情况下被编译器隐式使用，并与方法解析交互。相关规则专门设计用于适应智能指针，因此这些特征应仅用于此目的。</p>
<h3 id="标准库中的示例-3"><a class="header" href="#标准库中的示例-3">标准库中的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> 是指向 <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a> 的智能指针</li>
<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow&lt;'a, T&gt;</code></a></li>
</ul>
<p><a id="c-ctor"></a></p>
<h2 id="构造函数是静态的固有的方法-c-ctor"><a class="header" href="#构造函数是静态的固有的方法-c-ctor">构造函数是静态的、固有的方法 (C-CTOR)</a></h2>
<p>在 Rust 中，“构造函数”只是一个约定。关于构造函数命名有各种约定，区别往往微妙。</p>
<p>最基本形式的构造函数是一个无参数的 <code>new</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Example&lt;T&gt; {
    pub fn new() -&gt; Example&lt;T&gt; { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p>构造函数是为它们所构造的类型定义的静态（无 <code>self</code>）固有方法。结合完全导入类型名称的做法，这种约定可导致信息丰富但简洁的构造：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use example::Example;

// 构造一个新的 Example。
let ex = Example::new();
<span class="boring">}</span></code></pre></pre>
<p>名称 <code>new</code> 通常用于实例化类型的主要方法。有时它不带参数，如上例。有时它确实带有参数，如将值放入 <code>Box</code> 的 <a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a>。</p>
<p>一些类型的构造函数，尤其是 I/O 资源类型，使用与其构造函数相对应的命名约定，如 <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.open"><code>File::open</code></a>、<a href="https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open"><code>Mmap::open</code></a>、<a href="https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html#method.bind"><code>UdpSocket::bind</code></a>。在这些情况下，名称是根据具体领域选择的。</p>
<p>通常，有多种方式构造一个类型。在这些情况下，辅助构造函数常常带有 <code>_with_foo</code> 后缀，如 <a href="https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open_with_offset"><code>Mmap::open_with_offset</code></a>。如果你的类型有多种构造选项，请考虑使用构建器模式 (<a href="type-safety.html#c-builder">C-BUILDER</a>)。</p>
<p>一些构造函数是“转换构造函数”，即从其他类型的现有值创建新类型的方法。它们通常具有以 <code>from_</code> 开头的名称，如 <a href="https://doc.rust-lang.org/std/io/struct.Error.html#method.from_raw_os_error"><code>std::io::Error::from_raw_os_error</code></a>。但也请注意 <code>From</code> 特征 (<a href="interoperability.html#c-conv-traits">C-CONV-TRAITS</a>)，它与此非常相似。<code>from_</code> 前缀的转换构造函数和 <code>From&lt;T&gt;</code> 实现之间有三个区别：</p>
<ul>
<li><code>from_</code> 构造函数可以是 unsafe 的；而 <code>From</code> 实现不能。例如 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw"><code>Box::from_raw</code></a>。</li>
<li><code>from_</code> 构造函数可以接受附加参数来消除源数据的意义，以 <a href="https://doc.rust-lang.org/std/primitive.u64.html#method.from_str_radix"><code>u64::from_str_radix</code></a> 为例。</li>
<li><code>From</code> 实现仅适用于当源数据类型足以确定输出数据类型的编码时。当输入只是数据包，如在 <a href="https://doc.rust-lang.org/std/primitive.u64.html#method.from_be"><code>u64::from_be</code></a> 或 <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a> 中，转换构造函数名称能够标识其意义。</li>
</ul>
<p>注意，通常且预期的做法是类型同时实现 <code>Default</code> 和一个 <code>new</code> 构造函数。对于同时拥有这两者的类型，它们应具有相同的行为。任何一个都可以通过另一个来实现。</p>
<h3 id="标准库中的示例-4"><a class="header" href="#标准库中的示例-4">标准库中的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Error.html#method.new"><code>std::io::Error::new</code></a> 是用于 IO 错误的常用构造函数。</li>
<li><a href="https://doc.rust-lang.org/std/io/struct.Error.html#method.from_raw_os_error"><code>std::io::Error::from_raw_os_error</code></a> 是基于从操作系统接收到的错误代码的转换构造函数。</li>
<li><a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a> 创建一个新容器类型，接受一个参数。</li>
<li><a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.open"><code>File::open</code></a> 打开一个文件资源。</li>
<li><a href="https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open_with_offset"><code>Mmap::open_with_offset</code></a> 打开一个内存映射文件，并带有附加选项。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="灵活性"><a class="header" href="#灵活性">灵活性</a></h1>
<p><a id="c-intermediate"></a></p>
<h2 id="函数暴露中间结果以避免重复工作-c-intermediate"><a class="header" href="#函数暴露中间结果以避免重复工作-c-intermediate">函数暴露中间结果以避免重复工作 (C-INTERMEDIATE)</a></h2>
<p>许多函数在回答问题的同时也计算了相关的有趣数据。如果这些数据对客户端可能有用，应该考虑在 API 中暴露这些数据。</p>
<h3 id="标准库中的示例-5"><a class="header" href="#标准库中的示例-5">标准库中的示例</a></h3>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.binary_search"><code>Vec::binary_search</code></a> 不返回一个表示是否找到值的 <code>bool</code>，也不返回一个表示可能找到值的索引的 <code>Option&lt;usize&gt;</code>。它返回的是有关索引的信息，如果找到则返回索引，如果没找到则返回插入值所需的索引。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a> 如果输入字节不是 UTF-8，则可能会失败。在错误情况下，它返回一个中间结果，该结果显示输入中有效 UTF-8 的字节偏移量，并返还输入字节的所有权。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.insert"><code>HashMap::insert</code></a> 返回一个 <code>Option&lt;T&gt;</code>，它返回给定键的预存在值，如果有的话。对于用户想要恢复这个值的情况，由插入操作返回它可以避免用户进行第二次哈希表查找。</p>
</li>
</ul>
<p><a id="c-caller-control"></a></p>
<h2 id="调用者决定复制和放置数据的位置-c-caller-control"><a class="header" href="#调用者决定复制和放置数据的位置-c-caller-control">调用者决定复制和放置数据的位置 (C-CALLER-CONTROL)</a></h2>
<p>如果函数需要参数的所有权，它应该接收参数的所有权，而不是借用和克隆参数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 优先这样：
fn foo(b: Bar) {
    /* 直接使用 b 的所有权 */
}

// 而不是这样：
fn foo(b: &amp;Bar) {
    let b = b.clone();
    /* 克隆后使用 b 的所有权 */
}
<span class="boring">}</span></code></pre></pre>
<p>如果函数<em>不需要</em>参数的所有权，它应该借用参数，而不是获取所有权并丢弃参数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 优先这样：
fn foo(b: &amp;Bar) {
    /* 借用 b 使用 */
}

// 而不是这样：
fn foo(b: Bar) {
    /* 借用 b 使用，函数返回前会隐式丢弃 */
}
<span class="boring">}</span></code></pre></pre>
<p>只有在绝对需要时才应将 <code>Copy</code> trait 用作约束，而不是作为标记副本应该容易制作的方式。</p>
<p><a id="c-generic"></a></p>
<h2 id="函数通过使用泛型来最小化对参数的假设-c-generic"><a class="header" href="#函数通过使用泛型来最小化对参数的假设-c-generic">函数通过使用泛型来最小化对参数的假设 (C-GENERIC)</a></h2>
<p>函数对其输入做出的假设越少，其可用性就越广。</p>
<p>优先</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;I: IntoIterator&lt;Item = i64&gt;&gt;(iter: I) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>而不是任何以下实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(c: &amp;[i64]) { /* ... */ }
fn foo(c: &amp;Vec&lt;i64&gt;) { /* ... */ }
fn foo(c: &amp;SomeOtherCollection&lt;i64&gt;) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>如果函数只需要迭代数据。</p>
<p>更一般地，考虑使用泛型来准确地点出函数需要对其参数进行的假设。</p>
<h3 id="泛型的优势"><a class="header" href="#泛型的优势">泛型的优势</a></h3>
<ul>
<li>
<p><em>重用性</em>。泛型函数可以应用于一个开放式的类型集合，同时为这些类型需要提供的功能提供一个清晰的契约。</p>
</li>
<li>
<p><em>静态调度和优化</em>。每次使用泛型函数时，都会专门为实现 trait 约束的特定类型进行“单态化”，这意味着 (1) trait 方法的调用为静态的、直接的实现调用，（2）编译器可以内联和进一步优化这些调用。</p>
</li>
<li>
<p><em>内联布局</em>。如果一个 <code>struct</code> 和 <code>enum</code> 类型是某个类型参数 <code>T</code> 的泛型，<code>T</code> 类型的值将在 <code>struct</code>/<code>enum</code> 中内联布局，而没有任何间接性。</p>
</li>
<li>
<p><em>推断</em>。由于通常可以推断给泛型函数的类型参数，泛型函数可以帮助减少代码中的冗长，通常无需显式转换或其他方法调用。</p>
</li>
<li>
<p><em>精确类型</em>。因为泛型为实现一个 trait 的特定类型提供了一个_名称_，所以可以准确地表示需要或产生该确切类型的地方。例如，一个函数</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn binary&lt;T: Trait&gt;(x: T, y: T) -&gt; T
<span class="boring">}</span></code></pre></pre>
<p>可以保证使用和返回完全相同类型 <code>T</code> 的元素；不能用不同类型的参数调用此函数，即使这些类型都实现了 <code>Trait</code>。</p>
</li>
</ul>
<h3 id="泛型的劣势"><a class="header" href="#泛型的劣势">泛型的劣势</a></h3>
<ul>
<li>
<p><em>代码大小</em>。专用的泛型函数意味着函数主体被复制。必须权衡代码大小的增加与静态调度的性能收益之间的关系。</p>
</li>
<li>
<p><em>同质类型</em>。这是“精确类型”问题的另一面：如果 <code>T</code> 是一个类型参数，它代表一个_单一_实际类型。因此，例如，<code>Vec&lt;T&gt;</code> 包含单一具体类型的元素（实际上，矢量表示被专门用于内联这些元素）。有时，异类集合是有用的；见 <a href="flexibility.html#c-object">trait 对象</a>。</p>
</li>
<li>
<p><em>签名冗长</em>。大量使用泛型可能使函数的签名更难以阅读和理解。</p>
</li>
</ul>
<h3 id="标准库中的示例-6"><a class="header" href="#标准库中的示例-6">标准库中的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> 接受一个通用类型 <code>AsRef&lt;Path&gt;</code> 的参数。这允许通过字符串字面量 <code>"f.txt"</code>、<a href="https://doc.rust-lang.org/std/path/struct.Path.html"><code>Path</code></a>、<a href="https"><code>OsString</code></a> 和一些其他类型方便地打开文件。</li>
</ul>
<p><a id="c-object"></a></p>
<h2 id="具有潜在用途的-trait-对象是对象安全的-c-object"><a class="header" href="#具有潜在用途的-trait-对象是对象安全的-c-object">具有潜在用途的 trait 对象是对象安全的 (C-OBJECT)</a></h2>
<p>trait 对象有一些显著的限制：通过 trait 对象调用的方法不能使用泛型，并且不能在接收者位置之外使用 <code>Self</code>。</p>
<p>设计 trait 时，及早决定是将它用作对象还是用作泛型的约束。</p>
<p>如果一个 trait 是被用作对象，其方法应该接收和返回 trait 对象而不是使用泛型。</p>
<p><code>where</code> 子句 <code>Self: Sized</code> 可用于将特定方法从 trait 的对象中排除出去。以下 trait 由于泛型方法而不是对象安全的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    fn object_safe(&amp;self, i: i32);

    fn not_object_safe&lt;T&gt;(&amp;self, t: T);
}
<span class="boring">}</span></code></pre></pre>
<p>为泛型方法添加 <code>Self: Sized</code> 要求，将其从 trait 对象中排除，使 trait 对象安全。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    fn object_safe(&amp;self, i: i32);

    fn not_object_safe&lt;T&gt;(&amp;self, t: T) where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-对象的优点"><a class="header" href="#trait-对象的优点">trait 对象的优点</a></h3>
<ul>
<li><em>异构性</em>。当你需要它时，你真的需要它。</li>
<li><em>代码大小</em>。与泛型不同，trait 对象不生成专用（单态化）的代码版本，这可以大大减少代码大小。</li>
</ul>
<h3 id="trait-对象的缺点"><a class="header" href="#trait-对象的缺点">trait 对象的缺点</a></h3>
<ul>
<li><em>无泛型方法</em>。trait 对象目前不能提供泛型方法。</li>
<li><em>动态调度和胖指针</em>。trait 对象本身涉及间接性和 vtable 调度，这可能带来性能上的代价。</li>
<li><em>无 Self</em>。除接收者参数以外，trait 对象上的方法不能使用 <code>Self</code> 类型。</li>
</ul>
<h3 id="标准库中的示例-7"><a class="header" href="#标准库中的示例-7">标准库中的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>io::Read</code></a> 和 <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>io::Write</code></a> trait 经常用作对象。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait 有几个用 <code>where Self: Sized</code> 标记的泛型方法，以保留将 <code>Iterator</code> 用作对象的能力。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型安全"><a class="header" href="#类型安全">类型安全</a></h1>
<p><a id="c-newtype"></a></p>
<h2 id="新类型提供静态区分-c-newtype"><a class="header" href="#新类型提供静态区分-c-newtype">新类型提供静态区分 (C-NEWTYPE)</a></h2>
<p>新类型可以静态地区分底层类型的不同解释。</p>
<p>例如，一个 <code>f64</code> 值可能用来表示以英里或公里为单位的数量。通过使用新类型，我们可以跟踪预期的解释：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Miles(pub f64);
struct Kilometers(pub f64);

impl Miles {
    fn to_kilometers(self) -&gt; Kilometers { /* ... */ }
}
impl Kilometers {
    fn to_miles(self) -&gt; Miles { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p>一旦我们将这两种类型分开，我们就可以静态地确保不会混淆它们。例如，以下函数</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn are_we_there_yet(distance_travelled: Miles) -&gt; bool { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>不能被意外地传入一个 <code>Kilometers</code> 值。编译器会提醒我们进行转换，从而避免某些<a href="http://en.wikipedia.org/wiki/Mars_Climate_Orbiter">灾难性的错误</a>。</p>
<p><a id="c-custom-type"></a></p>
<h2 id="参数通过类型传达意义而不是-bool-或-option-c-custom-type"><a class="header" href="#参数通过类型传达意义而不是-bool-或-option-c-custom-type">参数通过类型传达意义，而不是 <code>bool</code> 或 <code>Option</code> (C-CUSTOM-TYPE)</a></h2>
<p>推荐使用</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let w = Widget::new(Small, Round)
<span class="boring">}</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let w = Widget::new(true, false)
<span class="boring">}</span></code></pre></pre>
<p><code>bool</code>、<code>u8</code> 和 <code>Option</code> 等核心类型有许多可能的解释。</p>
<p>使用明确的类型（无论是枚举、结构体还是元组）来传达解释和不变量。在上面的例子中，如果不查找参数名称，很难立即理解 <code>true</code> 和 <code>false</code> 所表达的含义，而 <code>Small</code> 和 <code>Round</code> 则更具暗示性。</p>
<p>使用自定义类型使得以后扩展选项变得更加容易，例如通过添加 <code>ExtraLarge</code> 变体。</p>
<p>有关包装现有类型并赋予其区别名称的无成本方法，请参见新类型模式 (<a href="type-safety.html#c-newtype">C-NEWTYPE</a>)。</p>
<p><a id="c-bitflag"></a></p>
<h2 id="标志集的类型应使用-bitflags而不是枚举-c-bitflag"><a class="header" href="#标志集的类型应使用-bitflags而不是枚举-c-bitflag">标志集的类型应使用 <code>bitflags</code>，而不是枚举 (C-BITFLAG)</a></h2>
<p>Rust 支持具有显式指定判别值的 <code>enum</code> 类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}
<span class="boring">}</span></code></pre></pre>
<p>当 <code>enum</code> 类型需要与其他系统/语言兼容地序列化为整数值时，自定义判别值非常有用。它们支持“类型安全”的 API：通过接受 <code>Color</code> 类型而不是整数，函数可以确保获得格式良好的输入，即使稍后将这些输入视为整数。</p>
<p>一个 <code>enum</code> 允许 API 从多个选项中准确请求一个选择。而有时，API 的输入是多个标志的存在或不存在。在 C 代码中，这通常通过让每个标志对应一个特定位来实现，从而允许一个整数表示 32 或 64 个标志。Rust 的 <a href="https://github.com/bitflags/bitflags"><code>bitflags</code></a> crate 提供了这种模式的类型安全表示。</p>
<pre><pre class="playground"><code class="language-rust">use bitflags::bitflags;

bitflags! {
    struct Flags: u32 {
        const FLAG_A = 0b00000001;
        const FLAG_B = 0b00000010;
        const FLAG_C = 0b00000100;
    }
}

fn f(settings: Flags) {
    if settings.contains(Flags::FLAG_A) {
        println!("执行操作 A");
    }
    if settings.contains(Flags::FLAG_B) {
        println!("执行操作 B");
    }
    if settings.contains(Flags::FLAG_C) {
        println!("执行操作 C");
    }
}

fn main() {
    f(Flags::FLAG_A | Flags::FLAG_C);
}</code></pre></pre>
<p><a id="c-builder"></a></p>
<h2 id="构建器支持复杂值的构建-c-builder"><a class="header" href="#构建器支持复杂值的构建-c-builder">构建器支持复杂值的构建 (C-BUILDER)</a></h2>
<p>有些数据结构由于其构建需要：</p>
<ul>
<li>大量输入</li>
<li>复合数据（例如切片）</li>
<li>可选的配置数据</li>
<li>在多种模式之间进行选择</li>
</ul>
<p>这很容易导致大量的独立构造函数，每个构造函数都有许多参数。</p>
<p>如果 <code>T</code> 是这样一个数据结构，可以考虑引入一个 <code>T</code> <em>构建器</em>：</p>
<ol>
<li>引入一个单独的数据类型 <code>TBuilder</code>，用于逐步配置一个 <code>T</code> 值。如果可能的话，选择一个更好的名称：例如 <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> 是一个 <a href="https://doc.rust-lang.org/std/process/struct.Child.html">子进程</a> 的构建器，<a href="https://docs.rs/url/1.4.0/url/struct.Url.html"><code>Url</code></a> 可以从 <a href="https://docs.rs/url/1.4.0/url/struct.ParseOptions.html"><code>ParseOptions</code></a> 创建。</li>
<li>构建器的构造函数应该只接受构造 <code>T</code> 所需的数据作为参数。</li>
<li>构建器应提供一套方便的方法进行配置，包括逐步设置复合输入（如切片）。这些方法应返回 <code>self</code> 以允许链式调用。</li>
<li>构建器应提供一个或多个“<em>终端</em>”方法来实际构建一个 <code>T</code>。</li>
</ol>
<p>当构建一个 <code>T</code> 涉及副作用（如启动任务或进程）时，构建器模式尤其合适。</p>
<p>在 Rust 中，有两种不同的构建器模式，区别在于所有权的处理，如下所述。</p>
<h3 id="非消费型构建器首选"><a class="header" href="#非消费型构建器首选">非消费型构建器（首选）</a></h3>
<p>在某些情况下，构建最终的 <code>T</code> 并不需要消费构建器本身。以下是 <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a> 的一个示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 注意：实际的 Command API 并不使用拥有的字符串；
// 这是一个简化版本。

pub struct Command {
    program: String,
    args: Vec&lt;String&gt;,
    cwd: Option&lt;String&gt;,
    // 等等
}

impl Command {
    pub fn new(program: String) -&gt; Command {
        Command {
            program: program,
            args: Vec::new(),
            cwd: None,
        }
    }

    /// 添加一个传递给程序的参数。
    pub fn arg(&amp;mut self, arg: String) -&gt; &amp;mut Command {
        self.args.push(arg);
        self
    }

    /// 添加多个传递给程序的参数。
    pub fn args(&amp;mut self, args: &amp;[String]) -&gt; &amp;mut Command {
        self.args.extend_from_slice(args);
        self
    }

    /// 设置子进程的工作目录。
    pub fn current_dir(&amp;mut self, dir: String) -&gt; &amp;mut Command {
        self.cwd = Some(dir);
        self
    }

    /// 以子进程的形式执行命令，并返回子进程。
    pub fn spawn(&amp;self) -&gt; io::Result&lt;Child&gt; {
        /* ... */
    }
}
<span class="boring">}</span></code></pre></pre>
<p>注意，<code>spawn</code> 方法实际上使用构建器配置来启动进程，它通过共享引用来获取构建器。这是可能的，因为启动进程并不需要配置数据的所有权。</p>
<p>由于终端 <code>spawn</code> 方法只需要引用，配置方法接受并返回 <code>self</code> 的可变借用。</p>
<h4 id="优点"><a class="header" href="#优点">优点</a></h4>
<p>通过在整个过程中使用借用，<code>Command</code> 可以方便地用于一行代码和更复杂的构建：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一行代码
Command::new("/bin/cat").arg("file.txt").spawn();

// 复杂配置
let mut cmd = Command::new("/bin/ls");
if size_sorted {
    cmd.arg("-S");
}
cmd.arg(".");
cmd.spawn();
<span class="boring">}</span></code></pre></pre>
<h3 id="消费型构建器"><a class="header" href="#消费型构建器">消费型构建器</a></h3>
<p>有时构建器在构建最终类型 <code>T</code> 时必须转移所有权，这意味着终端方法必须接受 <code>self</code> 而不是 <code>&amp;self</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TaskBuilder {
    /// 为即将创建的任务命名。
    pub fn named(mut self, name: String) -&gt; TaskBuilder {
        self.name = Some(name);
        self
    }

    /// 重定向任务本地的标准输出。
    pub fn stdout(mut self, stdout: Box&lt;io::Write + Send&gt;) -&gt; TaskBuilder {
        self.stdout = Some(stdout);
        self
    }

    /// 创建并执行一个新的子任务。
    pub fn spawn&lt;F&gt;(self, f: F) where F: FnOnce() + Send {
        /* ... */
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这里，<code>stdout</code> 配置涉及传递 <code>io::Write</code> 的所有权，该所有权必须在构建时转移到任务中（在 <code>spawn</code> 中）。</p>
<p>当构建器的终端方法需要所有权时，存在一个基本的权衡：</p>
<ul>
<li>
<p>如果其他构建器方法接受/返回可变借用，复杂配置情况会很好处理，但一行代码的配置变得不可能。</p>
</li>
<li>
<p>如果其他构建器方法接受/返回拥有的 <code>self</code>，一行代码的配置仍然可以正常工作，但复杂配置变得不太方便。</p>
</li>
</ul>
<p>在使简单的事情</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可靠性"><a class="header" href="#可靠性">可靠性</a></h1>
<p><a id="c-validate"></a></p>
<h2 id="函数应验证其参数-c-validate"><a class="header" href="#函数应验证其参数-c-validate">函数应验证其参数 (C-VALIDATE)</a></h2>
<p>Rust API 通常<strong>不</strong>遵循<a href="http://en.wikipedia.org/wiki/Robustness_principle">鲁棒性原则</a>：“对外发送信息时要保守；对接收到的信息要宽容”。</p>
<p>相反，Rust 代码应尽可能地<strong>强制</strong>输入的有效性。</p>
<p>可以通过以下机制实现强制验证（按优先顺序列出）。</p>
<h3 id="静态验证"><a class="header" href="#静态验证">静态验证</a></h3>
<p>选择一种可以排除无效输入的参数类型。</p>
<p>例如，优先选择</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: Ascii) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: u8) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>其中 <code>Ascii</code> 是 <code>u8</code> 的一个<strong>包装类型</strong>，它保证最高位为零；有关创建类型安全包装器的更多细节，请参见 newtype 模式 (<a href="type-safety.html#c-newtype">C-NEWTYPE</a>)。</p>
<p>静态验证通常几乎不带来运行时成本：它将成本推到边界（例如，当 <code>u8</code> 首次转换为 <code>Ascii</code> 时）。它还可以在编译期间捕获错误，而不是通过运行时失败来发现错误。</p>
<p>另一方面，有些属性很难或不可能用类型来表达。</p>
<h3 id="动态验证"><a class="header" href="#动态验证">动态验证</a></h3>
<p>在处理输入时（或在必要时提前）验证输入。动态检查通常比静态检查更容易实现，但也有几个缺点：</p>
<ol>
<li>运行时开销（除非检查可以作为处理输入的一部分完成）。</li>
<li>错误的检测延迟。</li>
<li>引入失败情况，无论是通过 <code>panic!</code> 还是 <code>Result</code>/<code>Option</code> 类型，这些都必须由客户端代码处理。</li>
</ol>
<h4 id="使用-debug_assert-的动态验证"><a class="header" href="#使用-debug_assert-的动态验证">使用 <code>debug_assert!</code> 的动态验证</a></h4>
<p>与动态验证相同，但可以轻松地在生产构建中关闭昂贵的检查。</p>
<h4 id="动态验证的选择退出"><a class="header" href="#动态验证的选择退出">动态验证的选择退出</a></h4>
<p>与动态验证相同，但增加了可以选择退出检查的同类函数。</p>
<p>惯例是使用类似 <code>_unchecked</code> 的后缀标记这些选择退出检查的函数，或者将它们放在 <code>raw</code> 子模块中。</p>
<p>在以下情况下，可以慎重使用未经检查的函数：(1) 性能要求避免检查，并且 (2) 客户端可以确信输入是有效的。</p>
<p><a id="c-dtor-fail"></a></p>
<h2 id="析构函数不应失败-c-dtor-fail"><a class="header" href="#析构函数不应失败-c-dtor-fail">析构函数不应失败 (C-DTOR-FAIL)</a></h2>
<p>析构函数在发生 panic 时执行，在这种情况下，如果析构函数失败会导致程序中止。</p>
<p>与其让析构函数失败，不如提供一个单独的方法来检查是否正常结束，例如 <code>close</code> 方法，该方法返回一个 <code>Result</code> 以表示问题。如果未调用该 <code>close</code> 方法，则 <code>Drop</code> 实现应进行清理，并忽略或记录/跟踪它产生的任何错误。</p>
<p><a id="c-dtor-block"></a></p>
<h2 id="可能阻塞的析构函数应提供替代方案-c-dtor-block"><a class="header" href="#可能阻塞的析构函数应提供替代方案-c-dtor-block">可能阻塞的析构函数应提供替代方案 (C-DTOR-BLOCK)</a></h2>
<p>同样，析构函数不应调用阻塞操作，这会使调试更加困难。再次考虑提供一个单独的方法来准备无错误的、非阻塞的清理工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试能力"><a class="header" href="#调试能力">调试能力</a></h1>
<p><a id="c-debug"></a></p>
<h2 id="所有公共类型都实现了-debug-c-debug"><a class="header" href="#所有公共类型都实现了-debug-c-debug">所有公共类型都实现了 <code>Debug</code> （C-DEBUG）</a></h2>
<p>如果有例外情况，也应该极为罕见。</p>
<p><a id="c-debug-nonempty"></a></p>
<h2 id="debug-的表现形式永远不为空c-debug-nonempty"><a class="header" href="#debug-的表现形式永远不为空c-debug-nonempty"><code>Debug</code> 的表现形式永远不为空（C-DEBUG-NONEMPTY）</a></h2>
<p>即使对于概念上为空的值，<code>Debug</code> 的表现形式也不应该是空的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let empty_str = "";
assert_eq!(format!("{:?}", empty_str), "\"\"");

let empty_vec = Vec::&lt;bool&gt;::new();
assert_eq!(format!("{:?}", empty_vec), "[]");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="未来适应性"><a class="header" href="#未来适应性">未来适应性</a></h1>
<p><a id="c-sealed"></a></p>
<h2 id="封闭的特征防止下游实现-c-sealed"><a class="header" href="#封闭的特征防止下游实现-c-sealed">封闭的特征防止下游实现 (C-SEALED)</a></h2>
<p>某些特征（traits）仅应在定义它们的 crate 内部实现。在这种情况下，我们可以通过使用封闭特征模式来保留改变特征的能力，而不引入不兼容更改。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 此特征是封闭的，不能在本 crate 之外为类型实现。
pub trait TheTrait: private::Sealed {
    // 一个或多个用户可调用的方法。
    fn ...();

    // 一个或多个私有方法，不允许用户调用。
    #[doc(hidden)]
    fn ...();
}

// 为某些类型实现。
impl TheTrait for usize {
    /* ... */
}

mod private {
    pub trait Sealed {}

    // 为相同的类型实现，但不为其他类型实现。
    impl Sealed for usize {}
}
<span class="boring">}</span></code></pre></pre>
<p>空的私有 <code>Sealed</code> 超特征无法被下游 crate 命名，因此我们可以确保 <code>Sealed</code>（因此也包括 <code>TheTrait</code>）的实现仅存在于当前 crate 中。我们可以在非破坏性的版本中添加方法到 <code>TheTrait</code>，即使这通常是对于未封闭特征的破坏性更改。此外，我们可以更改未公开文档的方法的签名。</p>
<p>请注意，移除公共方法或更改封闭特征中公共方法的签名仍然是破坏性的更改。</p>
<p>为了避免用户尝试实现该特征的挫折，应该在 rustdoc 中记录该特征是封闭的且不应在当前 crate 之外实现。</p>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<ul>
<li><a href="https://docs.serde.rs/serde_json/value/trait.Index.html"><code>serde_json::value::Index</code></a></li>
<li><a href="https://docs.rs/byteorder/1.1.0/byteorder/trait.ByteOrder.html"><code>byteorder::ByteOrder</code></a></li>
</ul>
<p><a id="c-struct-private"></a></p>
<h2 id="结构体具有私有字段-c-struct-private"><a class="header" href="#结构体具有私有字段-c-struct-private">结构体具有私有字段 (C-STRUCT-PRIVATE)</a></h2>
<p>将字段设为公共是一项强大的承诺：它固定了一种表示选择，并且禁止该类型提供任何验证或维持字段内容的不变量，因为客户端可以随意修改它。</p>
<p>公共字段最适用于 C 精神中的 <code>struct</code> 类型：组合的、被动的数据结构。否则，请考虑提供 getter/setter 方法并隐藏字段。</p>
<p><a id="c-newtype-hide"></a></p>
<h2 id="新类型封装实现细节-c-newtype-hide"><a class="header" href="#新类型封装实现细节-c-newtype-hide">新类型封装实现细节 (C-NEWTYPE-HIDE)</a></h2>
<p>新类型可以用于隐藏表示细节，同时向客户端做出精确的承诺。</p>
<p>例如，考虑一个返回复合迭代器类型的函数 <code>my_transform</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter::{Enumerate, Skip};

pub fn my_transform&lt;I: Iterator&gt;(input: I) -&gt; Enumerate&lt;Skip&lt;I&gt;&gt; {
    input.skip(3).enumerate()
}
<span class="boring">}</span></code></pre></pre>
<p>我们希望向客户端隐藏该类型，以使客户端对返回类型的视图大致为 <code>Iterator&lt;Item = (usize, T)&gt;</code>。我们可以使用新类型模式来实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter::{Enumerate, Skip};

pub struct MyTransformResult&lt;I&gt;(Enumerate&lt;Skip&lt;I&gt;&gt;);

impl&lt;I: Iterator&gt; Iterator for MyTransformResult&lt;I&gt; {
    type Item = (usize, I::Item);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.next()
    }
}

pub fn my_transform&lt;I: Iterator&gt;(input: I) -&gt; MyTransformResult&lt;I&gt; {
    MyTransformResult(input.skip(3).enumerate())
}
<span class="boring">}</span></code></pre></pre>
<p>除了简化签名之外，这种新类型的使用允许我们向客户端承诺更少。客户端不知道结果迭代器是如何构造或表示的，这意味着表示可以在不破坏客户端代码的情况下更改。</p>
<p>Rust 1.26 还引入了 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md"><code>impl Trait</code></a> 特性，比新类型模式更为简洁，但有一些额外的权衡，特别是在表达上有限制。例如，返回实现 <code>Debug</code> 或 <code>Clone</code> 或其他迭代器扩展特征组合的迭代器可能会有问题。总之，对于内部 APIs，<code>impl Trait</code> 作为返回类型可能很好，甚至可能适用于公共 APIs，但可能并非所有情况下都合适。详情请参见新版指南中的 <a href="https://rust-lang.github.io/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html">"<code>impl Trait</code> for returning complex types with ease"</a> 部分。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn my_transform&lt;I: Iterator&gt;(input: I) -&gt; impl Iterator&lt;Item = (usize, I::Item)&gt; {
    input.skip(3).enumerate()
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-struct-bounds"></a></p>
<h2 id="数据结构不重复派生特征边界-c-struct-bounds"><a class="header" href="#数据结构不重复派生特征边界-c-struct-bounds">数据结构不重复派生特征边界 (C-STRUCT-BOUNDS)</a></h2>
<p>泛型数据结构不应使用可以派生的或其他不增加语义价值的特征边界。<code>derive</code> 属性中的每个特征都会被扩展为一个单独的 <code>impl</code> 块，只有泛型参数实现该特征时才适用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 推荐这样写：
#[derive(Clone, Debug, PartialEq)]
struct Good&lt;T&gt; { /* ... */ }

// 而不是这样：
#[derive(Clone, Debug, PartialEq)]
struct Bad&lt;T: Clone + Debug + PartialEq&gt; { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>在 <code>Bad</code> 上重复派生特征作为边界是不必要的，而且是向后兼容性的隐患。要说明这一点，考虑在上一个示例的结构上派生 <code>PartialOrd</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 非破坏性更改：
#[derive(Clone, Debug, PartialEq, PartialOrd)]
struct Good&lt;T&gt; { /* ... */ }

// 破坏性更改：
#[derive(Clone, Debug, PartialEq, PartialOrd)]
struct Bad&lt;T: Clone + Debug + PartialEq + PartialOrd&gt; { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>一般来说，向数据结构添加特征边界是破坏性更改，因为该结构的每个消费者都需要开始满足额外的边界。使用 <code>derive</code> 属性从标准库派生更多特征不是破坏性更改。</p>
<p>以下特征不应在数据结构的边界中使用：</p>
<ul>
<li><code>Clone</code></li>
<li><code>PartialEq</code></li>
<li><code>PartialOrd</code></li>
<li><code>Debug</code></li>
<li><code>Display</code></li>
<li><code>Default</code></li>
<li><code>Error</code></li>
<li><code>Serialize</code></li>
<li><code>Deserialize</code></li>
<li><code>DeserializeOwned</code></li>
</ul>
<p>对于其他不可派生的特征边界，它们严格来说不是结构定义所必需的，例如 <code>Read</code> 或 <code>Write</code>，存在一个灰色地带。它们可能更好地在定义中表达了类型的预期行为，但也限制了未来的扩展性。在数据结构上包含语义上有用的特征边界比包含可派生的特征边界的问题要小。</p>
<h3 id="例外情况"><a class="header" href="#例外情况">例外情况</a></h3>
<p>在以下三种情况下，结构体需要特征边界：</p>
<ol>
<li>数据结构指代特征上的相关类型。</li>
<li>边界是 <code>?Sized</code>。</li>
<li>数据结构有一个需要特征边界的 <code>Drop</code> 实现。 Rust 当前要求 <code>Drop</code> 实现上的所有特征边界也应出现在数据结构上。</li>
</ol>
<h3 id="标准库中的示例-8"><a class="header" href="#标准库中的示例-8">标准库中的示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> 指代 <code>Borrow</code> 特征上的相关类型。</li>
<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>std::boxed::Box</code></a> 放弃了隐式的 <code>Sized</code> 边界。</li>
<li><a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html"><code>std::io::BufWriter</code></a> 在其 <code>Drop</code> 实现中需要一个特征边界。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="必要性"><a class="header" href="#必要性">必要性</a></h1>
<p><a id="c-stable"></a></p>
<h2 id="稳定版-crate-的公共依赖必须稳定-c-stable"><a class="header" href="#稳定版-crate-的公共依赖必须稳定-c-stable">稳定版 Crate 的公共依赖必须稳定 (C-STABLE)</a></h2>
<p>一个 Crate 如果要被标记为稳定版（&gt;=1.0.0），则它所有的公共依赖也必须是稳定的。</p>
<p>公共依赖是指在当前 Crate 的公共 API 中使用的其他 Crate 的类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_my_thing(arg: other_crate::TheirThing) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>如果一个 Crate 包含了上述函数，那么 <code>other_crate</code> 也必须是稳定的，否则这个 Crate 无法被标记为稳定版。</p>
<p>要小心，因为公共依赖可能会在意想不到的地方出现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Error {
    private: ErrorImpl,
}

enum ErrorImpl {
    Io(io::Error),
    // 即使 other_crate 不是稳定的，这里也没问题，
    // 因为 ErrorImpl 是私有的。
    Dep(other_crate::Error),
}

// 哦不！这使得 other_crate 出现在了当前 Crate 的公共 API 中。
impl From&lt;other_crate::Error&gt; for Error {
    fn from(err: other_crate::Error) -&gt; Self {
        Error { private: ErrorImpl::Dep(err) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-permissive"></a></p>
<h2 id="crate-及其依赖必须具有宽松的许可证-c-permissive"><a class="header" href="#crate-及其依赖必须具有宽松的许可证-c-permissive">Crate 及其依赖必须具有宽松的许可证 (C-PERMISSIVE)</a></h2>
<p>Rust 项目生成的软件是双许可证的，既可以在 <a href="https://github.com/rust-lang/rust/blob/master/LICENSE-MIT">MIT</a> 许可证下发布，也可以在 <a href="https://github.com/rust-lang/rust/blob/master/LICENSE-APACHE">Apache 2.0</a> 许可证下发布。为了与 Rust 生态系统保持最大的兼容性，建议 Crate 也采用相同的双许可证方式，具体方法如下所述。其他许可选项在下面描述。</p>
<p>这些 API 指南并不详细解释 Rust 的许可证，但在 <a href="https://github.com/dtolnay/rust-faq#why-a-dual-mitasl2-license">Rust FAQ</a> 中有一些相关说明。这里的指南主要关注与 Rust 的互操作性问题，并未涵盖所有的许可选项。</p>
<p>要将 Rust 许可证应用于你的项目，可以在 <code>Cargo.toml</code> 中定义 <code>license</code> 字段，如下所示：</p>
<pre><code class="language-toml">[package]
name = "..."
version = "..."
authors = ["..."]
license = "MIT OR Apache-2.0"
</code></pre>
<p>然后在项目根目录下添加 <code>LICENSE-APACHE</code> 和 <code>LICENSE-MIT</code> 文件，文件内容应为许可证的文本（可以从 choosealicense.com 获取，例如 <a href="https://choosealicense.com/licenses/apache-2.0/">Apache-2.0</a> 和 <a href="https://choosealicense.com/licenses/mit/">MIT</a>）。</p>
<p>并在你的 README.md 的结尾添加：</p>
<pre><code>## License

Licensed under either of

 * Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
 * MIT license
   ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)

at your option.

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.
</code></pre>
<p>除了双 MIT/Apache-2.0 许可证外，Rust Crate 作者使用的另一种常见的许可方式是采用单一宽松许可证，例如 MIT 或 BSD。这种许可方式与 Rust 的许可完全兼容，因为它遵循了 Rust MIT 许可证的最低限制。</p>
<p>不建议仅选择 Apache 许可证的 Crate，因为虽然 Apache 许可证是一种宽松的许可证，但它比 MIT 和 BSD 许可证附加了更多限制，可能会在某些场景下阻碍或阻止它们的使用，因此仅有 Apache 许可证的软件在某些情况下无法使用 Rust 的大部分运行时栈。</p>
<p>Crate 的依赖许可证可能会影响该 Crate 本身的分发限制，因此具有宽松许可证的 Crate 通常应该只依赖于具有宽松许可证的其他 Crate。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部链接"><a class="header" href="#外部链接">外部链接</a></h1>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md">RFC 199</a> - 所有权命名约定</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md">RFC 344</a> - 命名约定</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 430</a> - 命名约定</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> - 文档约定</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md">RFC 1574</a> - 文档约定</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1687">RFC 1687</a> - crate 级文档</li>
<li><a href="https://deterministic.space/elegant-apis-in-rust.html">Rust 中的优雅库 API</a></li>
<li><a href="https://rust-unofficial.github.io/patterns/">Rust 设计模式</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
